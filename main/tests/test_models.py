from django.test import TestCase
from main.models import Ingredient, FoodCategory, Recipe, Quantity, Comment
from django.contrib.auth.models import User
from django.db import IntegrityError
from django.core.exceptions import ValidationError, ObjectDoesNotExist
from decimal import *
from django.utils import timezone

# Create your tests here.


class IngredientModelTest(TestCase):

    def setUp(self):
        self.category = FoodCategory(name='Example Cat').save()
        self.example_ing = Ingredient(name='Example Ing',
                                      category=self.category,
                                      price=5,
                                      calval=1,
                                      total_carbs=1,
                                      total_fat=1,
                                      total_proteins=1)
        self.example_ing.save()
        self.second_ing = Ingredient(name='Second Ing',
                                     category=self.category,
                                     price=5,
                                     calval=1,
                                     total_carbs=1,
                                     total_fat=1,
                                     total_proteins=1)
        self.second_ing.save()

    def test_check_ingredient_slugifier(self):
        self.assertEqual(self.example_ing.slug, 'example-ing')

    def test_create_duplicate_ingredient(self):
        """
        Creating second ingredient with identical name (case-insensitive) should be unsuccessful due to unique constraint on
        autogenerated slug field
        """
        with self.assertRaises(IntegrityError):
            Ingredient.objects.create(name='eXaMpLe InG',
                                      category=FoodCategory.objects.get(name='Example Cat'),
                                      price=5,
                                      calval=1,
                                      total_carbs=1,
                                      total_fat=1,
                                      total_proteins=1)

    def test_check_for_invalid_macronutrients_qts(self):
        """
        Model's clean() method should prohibit from creating ingredients with macronutrient's sum exceeding 100g
        """
        with self.assertRaises(ValidationError):
            Ingredient.objects.create(name="Bodybuilder's dream",
                                      category=FoodCategory.objects.get(name='Example Cat'),
                                      price=0.1,
                                      calval=9999,
                                      total_carbs=300,
                                      total_fat=44,
                                      total_proteins=999)

    def test_default_values(self):
        self.assertEqual(self.example_ing.height_field, 0)
        self.assertEqual(self.example_ing.width_field, 0)
        self.assertFalse(self.example_ing.accepted)

    def test_blank_search(self):
        """
        Blank search should return unfiltered queryset with all created ingredients.
        """
        qs = Ingredient.objects.search()
        self.assertEqual(len(qs), 2)
        self.assertEqual(qs[0], self.example_ing)
        self.assertEqual(qs[1], self.second_ing)

    def test_no_match_search(self):
        qs = Ingredient.objects.search(query='Almond')
        self.assertEqual(len(qs), 0)

    def test_one_word_search(self):
        """
        In case of no results for full query search engine looks for individual words
        """
        qs = Ingredient.objects.search(query='Whatever Ing')
        self.assertEqual(len(qs), 2)

    def test_case_insensitive_exact_match_search(self):
        """
        Search feature is case insensitive and exact match prohibits single-word searching
        """
        qs = Ingredient.objects.search(query='exAmPle iNG')
        self.assertEqual(qs[0], self.example_ing)

    def test_stripping_s_search(self):
        """
        Query word ending with 's' shouldn't affect search
        """
        qs = Ingredient.objects.search(query='all ings')
        self.assertEqual(len(qs), 2)


class FoodCategoryModelTest(TestCase):

    def setUp(self):
        self.example_cat = FoodCategory(name='Example Cat')
        self.example_cat.save()

    def test_check_category_slugifier(self):
        self.assertEqual(self.example_cat.slug, 'example-cat')

    def test_create_duplicate_category(self):
        """
        Creating second category with identical name (case-insensitive) should be unsuccessful due to unique constraint on
        autogenerated slug field
        """
        with self.assertRaises(IntegrityError):
            FoodCategory.objects.create(name='ExAmPlE CaT')


class BaseRecipeRelatedTest(TestCase):
    """
    Separated setUp for recipe related test to avoid violating DRY.
    """

    def setUp(self):
        self.category = FoodCategory(name='Example Cat')
        self.category.save()
        # This user has autogenerated id=1, Recipe model default
        User.objects.create_user(username="user1", is_superuser=True, password="test1234")
        self.recipe = Recipe(recipe_name='Example Recipe')
        self.recipe2 = Recipe(recipe_name='Second Recipe')
        self.recipe.save()
        self.recipe2.save()

        defaults = {'name': 'Ing',
                    'category': self.category,
                    'price': 10,
                    'calval': 100,
                    'total_carbs': 10,
                    'total_fat': 10,
                    'total_proteins': 10}

        for i in range(1, 6):
            defaults['name'] = defaults['name'][:3] + str(i)
            defaults['price'] += 1
            defaults['calval'] += 10
            defaults['total_carbs'] += 4
            defaults['total_fat'] += 4
            defaults['total_proteins'] += 4
            ingredient = Ingredient(**defaults)
            ingredient.save()
            Quantity(recipe=self.recipe,
                     ingredient=ingredient,
                     quantity=100).save()
            # Second recipe is created without ing1 for the sake of search_by_ing test
            if i != 1:
                Quantity(recipe=self.recipe2,
                         ingredient=ingredient,
                         quantity=50).save()


class RecipeModelTest(BaseRecipeRelatedTest):

    def test_recipe_slugifier(self):
        self.assertEqual(self.recipe.recipe_slug, 'example-recipe')

    def test_recipe_default_values(self):
        self.assertEqual(self.recipe.height_field, 0)
        self.assertEqual(self.recipe.width_field, 0)
        self.assertEqual(self.recipe.preparation_time, 45)
        self.assertEqual(self.recipe.servings, 2)
        self.assertFalse(self.recipe.accepted)

    def test_recipe_calories_calculator(self):
        """
        Trigger recipe model pre-save receiver and check calories_per_serving value for quantities defined in setUp
        """
        self.recipe.save()
        self.assertEqual(self.recipe.calories_per_serving, 325)

    def test_recipe_price_calculator(self):
        """
        Trigger recipe model pre-save receiver and check price_per_serving value for quantities defined in setUp
        """
        self.recipe.save()
        self.assertEqual(self.recipe.price_per_serving, Decimal('3.25'))

    def test_recalculating(self):
        """
        Change number of servings and check recalculated values
        """
        self.recipe.servings = 3
        self.recipe.save()
        self.assertEqual(self.recipe.calories_per_serving, 217)
        self.assertEqual(self.recipe.price_per_serving, Decimal('2.17'))

    def test_recipe_posted(self):
        self.assertEqual(self.recipe.recipe_posted.replace(microsecond=0), timezone.now().replace(microsecond=0))

    def test_recipe_blank_search(self):
        qs = Recipe.objects.search()
        self.assertEqual(len(qs), 2)

    def test_recipe_search_method(self):
        qs = Recipe.objects.search(query='example')
        qs2 = Recipe.objects.search(query='second')
        qs3 = Recipe.objects.search(query='rec')
        self.assertEqual(len(qs), 1)
        self.assertEqual(qs[0], self.recipe)
        self.assertEqual(len(qs2), 1)
        self.assertEqual(qs2[0], self.recipe2)
        self.assertEqual(len(qs3), 2)

    def test_directions_search(self):
        """
        Search method should check if recipe directions contains queried string
        """
        self.recipe.directions = 'Some interesting details'
        self.recipe.save()
        qs = Recipe.objects.search(query='interesting detail')
        self.assertEqual(len(qs), 1)
        self.assertEqual(qs[0], self.recipe)

    def test_search_by_ingredient(self):

        ing1 = Ingredient.objects.get(name='Ing1')
        ing2 = Ingredient.objects.get(name='Ing2')
        qs = Recipe.objects.search_by_ing(ing=ing1)
        qs2 = Recipe.objects.search_by_ing(ing=ing2)
        self.assertEqual(len(qs), 1)
        self.assertEqual(qs[0], self.recipe)
        self.assertEqual(len(qs2), 2)
        self.assertEqual(qs2[1], self.recipe2)


class QuantityModelTest(BaseRecipeRelatedTest):

    def test_default_value(self):
        ing1 = Ingredient.objects.get(name='Ing1')
        qt = Quantity(recipe=self.recipe, ingredient=ing1)
        qt.save()
        self.assertEqual(qt.quantity, 5)

    def test_related_name(self):
        qs = self.recipe.quantities.all()
        self.assertEqual(len(qs), 5)

    def test_cascade_on_delete(self):
        self.recipe.delete()
        with self.assertRaises(ObjectDoesNotExist):
            Quantity.objects.get(pk=1)


class CommentModelTest(BaseRecipeRelatedTest):

    def test_default_values(self):
        comment = Comment(recipe=self.recipe, user=User.objects.get(pk=1))
        comment.save()
        self.assertFalse(comment.active)

    def test_cascade_on_delete(self):
        comment = Comment(recipe=self.recipe, user=User.objects.get(pk=1))
        comment.save()
        self.recipe.delete()

        with self.assertRaises(ObjectDoesNotExist):
            Comment.objects.get(pk=1)

    def test_created_on(self):
        comment = Comment(recipe=self.recipe, user=User.objects.get(pk=1))
        comment.save()

        self.assertEqual(comment.created_on.replace(microsecond=0), timezone.now().replace(microsecond=0))










