{% extends 'main/base.html' %}

{% block content %}
<div class="container">
<div class="row">
    <div class="col-sm-12" >
        <canvas id="gameCanvas" width="500px" height="560px" style="border:1px solid #000"></canvas>
        <!-- <canvas id="myChart" width="400" height="400"></canvas> -->
        <canvas id="myCanvas" width="200px" height="200px" style="border:1px solid #000"></canvas>
        <canvas id="yourCanvas" width="400px" height="500px" style="border:1px solid #000"></canvas>
<script>

    var y = 50
    var displayArray = function(array, i, nextMin) {

        const canv = document.getElementById('yourCanvas');
        const ctx = canv.getContext("2d");
        ctx.font = '20px serif'
        var x = 50
        for (elem of array){
            ctx.fillText(elem, x, y);
            x = x + 30;
        }
        if(i != array.length - 1){
            ctx.beginPath();
            ctx.moveTo(55 + nextMin*30, y + 2);
            ctx.lineTo(55 + i*30, y+35);
            ctx.stroke();
        }

        y = y + 50
    };



    var swap = function(array, firstIndex, secondIndex) {
        var temp = array[firstIndex];
        array[firstIndex] = array[secondIndex];
        array[secondIndex] = temp;
    };

    var indexOfMinimum = function(array, startIndex) {
        var minValue = array[startIndex];
        var minIndex = startIndex;

        for(var i = minIndex + 1; i < array.length; i++) {
            if(array[i] < minValue) {
                minIndex = i;
                minValue = array[i];
            }
        }
        return minIndex;
    };

    var selectionSort = function(array) {
        var nextMin;
        for(var i = 0 ; i < array.length; i++){
            nextMin = indexOfMinimum(array, i);
            displayArray(array, i, nextMin);
            swap(array, i, nextMin);
        }

    };

    var array = [2, 14, 9, 4 ,7 , 1, 9, 3 ];
    selectionSort(array);




    var insert = function(array, rightIndex, value) {
    for(var j = rightIndex;
        j >= 0 && array[j] > value;
        j--) {
        array[j + 1] = array[j];
    }
    array[j + 1] = value;
    };

    var insertionSort = function(array) {
        for(var i = 1; i < array.length; i++){
            insert(array, i-1, array[i]);
        }

    };


    /*const canvas = document.getElementById("myCanvas");
    const context = canvas.getContext("2d");
    const blobCount = 10;
    const colors = new Array('red','purple','yellow','blue','green','orange','pink','black');
    let blobs = new Array();
    class Blob {
        constructor(color, size){
            this.x = Math.random() * canvas.width;
            this.y = Math.random() * canvas.height;
            this.color = color;
            this.size = size;
            this.xChange = Math.random();
            this.yChange = Math.random();
        }
        move(){
            if ((this.x + this.size) >= canvas.width || (this.x - this.size) <= 0) {
            this.xChange *= -1
            }
            if((this.y + this.size) >= canvas.height || (this.y - this.size) <= 0){
                this.yChange *= -1
            }
            this.x = this.x + this.xChange;
            this.y = this.y + this.yChange;
        }
        draw(){
            context.beginPath();
            context.arc(this.x, this.y, this.size, 0, 2*Math.PI);
            context.fillStyle = this.color;
            context.fill();
            context.stroke();
        }
    }

    function randomChoice(arr){
        return arr[Math.floor(Math.random()*arr.length)]
    }

    for (let i=0; i<blobCount; i++){
        let randomColor = randomChoice(colors);
        blobs.push(new Blob(randomColor, 25))
    }

    function cDraw(){
        context.clearRect(0, 0, canvas.width, canvas.height);
        blobs.forEach(function(obj){
            obj.draw();
            obj.move();
        })
    }
    setInterval(cDraw, 10);*/




const cnv = document.getElementById('gameCanvas');
const c = cnv.getContext('2d');

class Platform{
    constructor(color, length, x, y, speed = 8, reverse = false){
        this.color = color;
        this.length = length;
        this.x = x - length/2;
        this.y = y;
        this.reverse = reverse;
        this.points = 0;
        this.speed = speed;

    }

    draw(){
        c.beginPath();
        if(this.reverse ){
            c.rect(this.x, this.y - 20, this.length, 20);
        }
        else{
            c.rect(this.x, this.y, this.length, 20);   
        }
        c. fillStyle = this.color;
        c.fill();
    }

    move(direction){
        // Dont move out of bounds
        if(!(this.x + this.length >= cnv.width && direction > 0 || 
             this.x <= 0 && direction < 0)){

            this.x = this.x + direction * this.speed;
        }
        
    }
}

class Ball{
    constructor(color, size, speed){
        this.color = color;
        this.size = size;
        this.speed = speed;
        this.x = 250;
        this.y = 400;
        this.xvector = -1;
        this.yvector = -1;

    }

    draw(){
        c.beginPath();
        c.arc(this.x, this.y, this.size, 0,  2*Math.PI);
        c. fillStyle = this.color;
        c.fill();
    }

    move(){
        if(this.x + this.size >= cnv.width || this.x - this.size <= 0){
            this.xvector *= -1
        }
        if(this.y + this.size >= cnv.height - 30 || this.y - this.size <= 30){
            this.yvector *= -1
        }
        
        this.x = this.x + this.xvector * this.speed;
        this.y = this.y + this.yvector * this.speed;
    }

    stop(){
        this.xvector = 0;
        this.yvector = 0;
    }

    start(direction){
        this.xvector = direction;
        if(this.y > cnv.height/2){
            this.yvector = -1;   
        }
        else{
            this.yvector = 1;
        }
        
    }

    bounce(platform){
        
        function distance(x1, y1, x2, y2){
            return Math.sqrt((y2-y1)**2 + (x2-x1)**2);
        }

        function define_direction(bb){
            if(bb.x < platform.x + platform.length/3     && bb.xvector > 0 ||
               bb.x > platform.x + platform.length*(2/3) && bb.xvector < 0){
                return -1;
            }
            return 1;
        }


        // Corners and sides
        if(distance(platform.x, platform.y, this.x, this.y) <= this.size ||
           distance(platform.x + platform.length, platform.y, this.x, this.y) <= this.size){
            console.log('doors and corners!')
            if((!platform.reverse && this.y >= platform.y) || (platform.reverse && this.y <= platform.y)){
                this.xvector *= -1
            }
            else{
                if(Math.abs(this.xvector) >= 1.4 || Math.abs(this.yvector) <= 0.6){
                    this.xvector *= define_direction(this) * 1
                    this.yvector *= -1
                } 
                else{
                    this.xvector *= define_direction(this) * 1.4
                    this.yvector *= -0.6
                }
            }
        }

        // Main platform area with left, right and center
        if((!platform.reverse && this.y + this.size >= platform.y)||
           (platform.reverse && this.y - this.size <= platform.y)){
            
            // Center area
            if(this.x >= platform.x + platform.length/3 && this.x <= platform.x + (2/3)*platform.length){
                // Slow down if needed
                if(Math.abs(this.xvector) >= 1.4 || Math.abs(this.yvector)<=0.6){
                    this.xvector = 1 * Math.sign(this.xvector)
                    this.yvector =-1
                }
                else{   
                    this.yvector *= -1
                }
            }
            // If not center and in platform, must be left or right. 
            // define_direction takes care of differentiation 
            else if(this.x >= platform.x  && this.x <= platform.x + platform.length){
                if(Math.abs(this.xvector) >= 1.4 || Math.abs(this.yvector)<=0.6){
                    this.xvector *= define_direction(this) * 1
                    this.yvector *= -1
                }
                else if(Math.abs(this.xvector) >= 1.2 || Math.abs(this.yvector) <= 0.8){
                    this.xvector *= define_direction(this) * 1.1
                    this.yvector *= -0.9
                } 
                else{
                    this.xvector *= define_direction(this) * 1.2   
                    this.yvector *= -0.8
                }
            }
        
        }
    }
    
}

myplatform = new Platform('red', 100, 250, 480, 12);
opponentplatform = new Platform('black', 100, 250, 80, 6, true);
ball = new Ball('green', 20, 1);

game = setInterval(canvasDraw, 7);

oponent = setInterval(move_opponent, 100, opponentplatform)

window.addEventListener('keydown', (e) => {
    
    if (e.keyCode == 37){  
        myplatform.move(-1);
        
        if(ball.yvector == 0){
            ball.start(-1)
        }
    }
    else if(e.keyCode == 39){
        myplatform.move(1);
        
        if(ball.yvector == 0){
            ball.start(1)
        }
    }
    else if(e.key == 'ArrowUp'){
        ball.start();
    }
    else if(e.key == 't'){
        clearInterval(game);
    }
    else if(e.key == 's'){
        game = setInterval(canvasDraw, 7);
    }
});

let last_move = 1;
let visible_range = 100;
function move_opponent(platform){
    function focus(){
        if(ball.yvector == 0 && ball.y < cnv.height/2){
            ball.start(last_move);
        }
        if(ball.x > platform.x + platform.length){
            platform.move(1);
            last_move = 1;
        }
        else if(ball.x < platform.x){
            platform.move(-1);
            last_move = -1;
        }
    }
    let a = Math.random();
    if(a > 0.1 && ball.yvector < visible_range){
        focus()
    }
    else if(a < 0.4){
        platform.move(last_move);
    }
    else if(a < 0.6){
        platform.move(last_move * - 1);
        last_move *= -1;
    } 
    else{ focus() }  
    

}

function canvasDraw(){
    c.clearRect(0, 0, cnv.width, cnv.height);
    myplatform.draw();
    opponentplatform.draw();

    c.beginPath();
    c.font = '20px serif'
    c.moveTo(0, 30);
    c.lineTo(cnv.width, 30);
    c.fillText('POINTS' , cnv.width - 150, 20 );
    c.fillText(opponentplatform.points, cnv.width -20, 20 );
    c.fillText('POINTS', 10,  cnv.height - 10 );
    c.fillText(myplatform.points, cnv.width -20,  cnv.height - 10 );
    c.moveTo(0, cnv.height - 30);
    c.lineTo(cnv.width, cnv.height -30);
    c.stroke();

    // Give points and position ball
    if(ball.y >= myplatform.y + 30){
        ball.stop();
        opponentplatform.points += 1;
        ball.x = myplatform.x + myplatform.length/2;
        ball.y = myplatform.y - ball.size - 2;
    }
    if(ball.y <= opponentplatform.y - 30){
        ball.stop();
        myplatform.points += 1;
        ball.x = opponentplatform.x + opponentplatform.length/2;
        ball.y = opponentplatform.y + ball.size + 2;
    }

    ball.draw();

    if(ball.y - ball.size < opponentplatform.y + 20){
        ball.bounce(opponentplatform);
    }
    else if(ball.y + ball.size > myplatform.y - 20){
        ball.bounce(myplatform);
    }
    ball.move();

}

//me = setInterval(move_opponent, 100, myplatform)

// maybe restrict platform movement to avoid buggy behavior "puncturing ball"
// levels with changing platforms and speeds
// Game OVER, press R to restart,
// LVL 1, 2, 3, next level


</script>
</div>
</div>
</div>
{% endblock %}